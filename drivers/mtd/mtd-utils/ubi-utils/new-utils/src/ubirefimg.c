/*
 * An utility to reformat the image file generated by mkfs.ubifs
 *
 * Authors:   Yurong Tan (Nancy)
 */

#include <fcntl.h>
#include <stdio.h>
#include <stdint.h>
#include <getopt.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/stat.h>


#define PROGRAM_VERSION "1.1"
#define PROGRAM_NAME    "ubirefimg"
#define UBI_LEB_SIZE	516096 

/*
 * sourcefile usually generated by mkfs.ubifs.
 * usage: #ubirefimg sourcefile outputfile 
 */
int main(int argc, char * const argv[])
{
	int err, ifd, ofd, i, j, tmp, leb_size = 0;
	struct stat st;
	unsigned char *buf=NULL;
	
	if (argc > 3)
		leb_size = atoi(argv[3]);
	else
		leb_size = UBI_LEB_SIZE;

	printf("%s: leb_size = %d\n", argv[0], leb_size);

	buf = malloc(leb_size);
	if(buf==NULL){
		printf("no mem\n");
		goto out_free;		
	}

	err = stat(argv[1], &st);
	if (err < 0) {
		printf("stat failed on \"%s\"", argv[1]);
		goto out_free;
	}
	
	ifd = open(argv[1],  O_RDONLY);
	if (ifd == -1) {
		printf("cannot open \"%s\"", argv[1]);
		goto out_close;
	}

	ofd = open(argv[2], O_WRONLY | O_TRUNC | O_CREAT, 0644);
	if (ofd == -1) {
		printf("cannot create \"%s\"", argv[2]);
		goto out_close;
	}
	
	tmp = st.st_size/leb_size;

	for( i=0;  i< tmp;  i++ ){
		err = read(ifd, buf, leb_size);
		if (err != leb_size) {
			printf("read error\n");
			goto out_close1;
		}
		for(j=0; j<leb_size; j++)
			if( buf[j] != 0xff )
				break;
		/* if that was an umapped LEB, skip */
		if(j == leb_size )
			continue;
                 /* write LEB's lnum */
		err = write(ofd, &i, sizeof(unsigned int));
		if (err != sizeof(unsigned int)) {
			printf("write error\n");
			goto out_close1;
		}
		/* write LEB's data */
		err = write(ofd, buf, leb_size);
		if (err != leb_size) {
			printf("write error\n");
			goto out_close1;
		}

	}

	free(buf);
	close(ifd);
	close(ofd);
	return 0;

out_close1:
	close(ofd);
out_close:
	close(ifd);
out_free:
	free(buf);
	return -1;
}


